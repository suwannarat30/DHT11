<script>
/* ===== WebSocket + Chart 2 เส้น ===== */
const BACKEND_WS = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
let ws;

function setText(id, value){
  const el = document.getElementById(id);
  if (el) el.textContent = value;
}

/* rolling history */
const MAX_POINTS = 60;
const series = { t: [], h: [], ts: [] };

const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
let dpi = 1;

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  dpi = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpi);
  canvas.height = Math.round(rect.height * dpi);
  drawChart(1);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function lerp(a,b,t){ return a + (b-a)*t; }
function niceRange(min, max){
  if (min === max) { min -= 1; max += 1; }
  const pad = (max - min) * 0.15;
  return [Math.floor(min - pad), Math.ceil(max + pad)];
}

let anim = { fromT:[], toT:[], fromH:[], toH:[], start:0, dur:800 };
function scheduleAnimation() {
  anim.fromT = anim.toT.slice();
  anim.fromH = anim.toH.slice();
  anim.toT   = series.t.slice();
  anim.toH   = series.h.slice();
  anim.start = performance.now();
  requestAnimationFrame(tick);
}
function tick(now){
  const p = Math.min(1, (now - anim.start)/anim.dur);
  drawChart(p);
  if (p < 1) requestAnimationFrame(tick);
}

function drawChart(progress=1){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  /* grid */
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.15)';
  ctx.lineWidth = 1;
  const gx = 8, gy = 5;
  for(let i=1;i<gx;i++){
    const x = (w/gx)*i;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }
  for(let i=1;i<gy;i++){
    const y = (h/gy)*i;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  ctx.restore();

  if (series.t.length < 2) return;

  const minT = Math.min(...series.t), maxT = Math.max(...series.t);
  const minH = Math.min(...series.h), maxH = Math.max(...series.h);
  const [yMinT,yMaxT] = niceRange(minT, maxT);
  const [yMinH,yMaxH] = niceRange(minH, maxH);

  const N = series.t.length;
  const pad = 16 * dpi;
  const plotW = w - pad*2;
  const plotH = h - pad*2;
  const xAt = i => pad + (i/(N-1))*plotW;
  const yAtT = v => pad + (1 - (v - yMinT)/(yMaxT - yMinT))*plotH;
  const yAtH = v => pad + (1 - (v - yMinH)/(yMaxH - yMinH))*plotH;

  const sample = (arrFrom, arrTo, i) => lerp(arrFrom[i] ?? arrTo[i], arrTo[i], progress);

  /* gradient pastel temperature */
  let gradT = ctx.createLinearGradient(0,0,0,h);
  gradT.addColorStop(0,"#ffe0d6");
  gradT.addColorStop(1,"#ffb3a1");

  ctx.save();
  ctx.lineWidth = 3 * dpi;
  ctx.strokeStyle = gradT;
  ctx.beginPath();
  for (let i=0;i<N;i++){
    const x = xAt(i);
    const y = yAtT(sample(anim.fromT, anim.toT, i));
    i? ctx.lineTo(x,y) : ctx.moveTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  /* gradient pastel humidity */
  let gradH = ctx.createLinearGradient(0,0,0,h);
  gradH.addColorStop(0,"#d1e8ff");
  gradH.addColorStop(1,"#9ecbff");

  ctx.save();
  ctx.lineWidth = 3 * dpi;
  ctx.strokeStyle = gradH;
  ctx.beginPath();
  for (let i=0;i<N;i++){
    const x = xAt(i);
    const y = yAtH(sample(anim.fromH, anim.toH, i));
    i? ctx.lineTo(x,y) : ctx.moveTo(x,y);
  }
  ctx.stroke();
  ctx.restore();
}

function pushPoint(temp, hum){
  const now = Date.now();
  series.t.push(Number(temp));
  series.h.push(Number(hum));
  series.ts.push(now);
  if (series.t.length > MAX_POINTS){
    series.t.shift(); series.h.shift(); series.ts.shift();
  }
  scheduleAnimation();
}

/* ==== WebSocket connect ==== */
function connectWS(){
  ws = new WebSocket(BACKEND_WS);
  ws.onopen = () => {
    setText("status-message","Connected ✅");
  };
  ws.onmessage = ev => {
    try {
      const data = JSON.parse(ev.data);
      if (data.temperature != null){
        const t = Number(data.temperature);
        setText("temperature-value", t.toFixed(1));
      }
      if (data.humidity != null){
        const h = Number(data.humidity);
        setText("humidity-value", h.toFixed(0));
        const donut = document.getElementById('humidity-donut');
        if (donut) donut.style.setProperty('--p', Math.max(0, Math.min(100, h)));
      }
      if (data.temperature!=null && data.humidity!=null){
        pushPoint(data.temperature, data.humidity);
      }
    } catch(err){ console.error("Parse error",err); }
  };
  ws.onclose = () => {
    setText("status-message","Disconnected ⚠️");
    setTimeout(connectWS, 3000);
  };
  ws.onerror = () => {
    setText("status-message","WebSocket Error ❌");
    ws.close();
  };
}

connectWS();
</script>
